================================================================================
                         SYSTEM WORKFLOW DOCUMENT
            Complete Guide to xv6 Event Queue System Workflow
================================================================================

Table of Contents:
  1. Overview
  2. Command Execution Workflow
  3. Event Recording Flow
  4. Watcher Monitoring Flow
  5. Complete Timeline Examples
  6. Kernel Internal Details
  7. Data Flow Diagrams
  8. Performance Metrics

================================================================================
1. OVERVIEW
================================================================================

The xv6 Kernel Event Queue System monitors three types of system events:
  - fork:  Process creation
  - sleep: Process waiting/blocking
  - write: Data output

When you execute a command in QEMU:
  1. Shell forks to create new process
  2. New process exec's the command
  3. Command runs and generates events
  4. Kernel records events in circular buffer
  5. Watcher reads events and logs them
  6. Shell waits for command to finish
  7. Process exits and returns to shell


================================================================================
2. COMMAND EXECUTION WORKFLOW
================================================================================

SCENARIO: User types "eventtest" in QEMU shell

┌─────────────────────────────────────────────────────────────────────────┐
│ STEP 1: User Input                                                      │
├─────────────────────────────────────────────────────────────────────────┤
│ Location: QEMU terminal                                                 │
│ $ eventtest                                                             │
│                                                                          │
│ What happens:                                                           │
│   - Keyboard input received by QEMU                                     │
│   - Characters buffered in kernel                                       │
│   - Shell reads from stdin                                              │
│   - Command string parsed: "eventtest"                                  │
└─────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────┐
│ STEP 2: Shell Calls fork()                                              │
├─────────────────────────────────────────────────────────────────────────┤
│ Location: user/sh.c, kernel/proc.c                                      │
│                                                                          │
│ Code in shell:                                                          │
│   int pid = fork();                                                     │
│   if(pid == 0) {                                                        │
│     // Child - will exec eventtest                                      │
│     exec("eventtest", argv);                                            │
│   } else {                                                              │
│     // Parent - wait for child                                          │
│     wait(0);                                                            │
│   }                                                                      │
│                                                                          │
│ Kernel actions:                                                         │
│   1. Save parent process state                                          │
│   2. Allocate new process structure (PCB)                               │
│   3. Copy parent's memory (address space)                               │
│   4. Copy parent's file descriptors                                     │
│   5. Create new stack for child                                         │
│   6. Set child's program counter to start                               │
│   7. Assign new PID to child                                            │
│   8. Add child to process list                                          │
│   9. RECORD EVENT: fork event to queue                                  │
│  10. Return child PID (0) to child, parent PID to parent                │
│                                                                          │
│ EVENT RECORDED:                                                         │
│   [timestamp] [parent_pid] fork                                         │
└─────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────┐
│ STEP 3: Child Process exec's eventtest                                  │
├─────────────────────────────────────────────────────────────────────────┤
│ Location: Child process context, kernel/exec.c                          │
│                                                                          │
│ Code in child:                                                          │
│   exec("eventtest", argv);                                              │
│                                                                          │
│ Kernel actions:                                                         │
│   1. Look up "eventtest" file in filesystem                             │
│   2. Read ELF header to verify executable                               │
│   3. Free old memory pages (from shell)                                 │
│   4. Allocate new memory pages                                          │
│   5. Load eventtest binary into memory                                  │
│   6. Load data/BSS sections                                             │
│   7. Set up stack with argc/argv                                        │
│   8. Set program counter to entry point                                 │
│   9. RECORD EVENT: write event (file I/O during load)                   │
│  10. Return to user space running eventtest code                        │
│                                                                          │
│ EVENT RECORDED:                                                         │
│   [timestamp] [child_pid] write                                         │
└─────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────┐
│ STEP 4: eventtest Runs - First printf()                                 │
├─────────────────────────────────────────────────────────────────────────┤
│ Location: user/eventtest.c, printf code                                 │
│                                                                          │
│ Code in eventtest:                                                      │
│   printf("Test: Creating fork events\n");                               │
│                                                                          │
│ User-space actions:                                                     │
│   1. printf() prepares format string                                    │
│   2. Calls write(1, "Test: Creating...", len)                           │
│                                                                          │
│ Kernel actions (sys_write):                                             │
│   1. Validate file descriptor (1 = stdout)                              │
│   2. Validate buffer address                                            │
│   3. Check permissions                                                  │
│   4. Write data to console device                                       │
│   5. RECORD EVENT: write event                                          │
│   6. Return number of bytes written                                     │
│                                                                          │
│ EVENT RECORDED:                                                         │
│   [timestamp] [eventtest_pid] write                                     │
│                                                                          │
│ Output on console:                                                      │
│   Test: Creating fork events                                            │
└─────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────┐
│ STEP 5: eventtest Creates Children via fork()                           │
├─────────────────────────────────────────────────────────────────────────┤
│ Location: user/eventtest.c                                              │
│                                                                          │
│ Code loop (i = 0, 1, 2):                                                │
│   for(int i = 0; i < 3; i++) {                                          │
│     int pid = fork();                                                   │
│     if(pid == 0) {                                                      │
│       printf("Child %d running\n", getpid());                           │
│       exit(0);                                                          │
│     } else if(pid > 0) {                                                │
│       wait(0);  // Parent waits for child                               │
│     }                                                                    │
│   }                                                                      │
│                                                                          │
│ Iteration 1 (i=0):                                                      │
│   - eventtest calls fork()                                              │
│     EVENT: [timestamp] [eventtest] fork                                 │
│   - Child (PID 7) created, exec's child code                            │
│   - Child prints "Child 7 running"                                      │
│     EVENT: [timestamp] [child7] write                                   │
│   - Child calls exit(0)                                                 │
│     EVENT: [timestamp] [child7] sleep (during cleanup)                  │
│   - eventtest calls wait(0)                                             │
│     EVENT: [timestamp] [eventtest] sleep (blocked waiting)              │
│   - Child finishes, wait() returns                                      │
│                                                                          │
│ Iteration 2 (i=1):                                                      │
│   - Same as iteration 1, but PID 8                                      │
│                                                                          │
│ Iteration 3 (i=2):                                                      │
│   - Same as iteration 1, but PID 9                                      │
│                                                                          │
│ EVENTS RECORDED:                                                        │
│   [t1] [eventtest] fork       # Create child 1                          │
│   [t2] [child7] write         # Child prints                            │
│   [t3] [child7] sleep         # Child exit                              │
│   [t4] [eventtest] fork       # Create child 2                          │
│   [t5] [child8] write         # Child prints                            │
│   [t6] [child8] sleep         # Child exit                              │
│   [t7] [eventtest] fork       # Create child 3                          │
│   [t8] [child9] write         # Child prints                            │
│   [t9] [child9] sleep         # Child exit                              │
└─────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────┐
│ STEP 6: eventtest Outputs Final Message                                 │
├─────────────────────────────────────────────────────────────────────────┤
│ Location: user/eventtest.c                                              │
│                                                                          │
│ Code:                                                                    │
│   printf("Test: Writing to console\n");                                 │
│   write(1, "Hello from test\n", 16);                                    │
│   exit(0);                                                              │
│                                                                          │
│ EVENTS RECORDED:                                                        │
│   [t10] [eventtest] write     # printf()                                │
│   [t11] [eventtest] write     # write()                                 │
│   [t12] [eventtest] sleep     # exit cleanup                            │
│                                                                          │
│ Output on console:                                                      │
│   Test: Writing to console                                              │
│   Hello from test                                                       │
└─────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────────────┐
│ STEP 7: Shell Resumes                                                   │
├─────────────────────────────────────────────────────────────────────────┤
│ Location: Shell (sh.c), shell context                                   │
│                                                                          │
│ What happens:                                                           │
│   - wait(0) in shell returns (eventtest finished)                       │
│   - Shell prints prompt: $                                              │
│   - Shell ready for next command                                        │
│                                                                          │
│ Total time for command: ~100-200ms                                      │
└─────────────────────────────────────────────────────────────────────────┘


================================================================================
3. EVENT RECORDING FLOW
================================================================================

Each event passes through these stages:

STAGE 1: EVENT TRIGGER
  └─→ fork() syscall in kernel
  └─→ sleep() syscall in kernel  
  └─→ write() syscall in kernel

STAGE 2: KERNEL EVENT RECORDING
  Location: kernel/proc.c, kernel/sysfile.c
  Action: kqueue_post(pid, "event_name")
  
  Code (example from fork):
    int fork(void) {
      // ... create process ...
      kqueue_post(p->pid, "fork");  // ← RECORD HERE
      // ... return ...
    }

STAGE 3: EVENT POSTED TO CIRCULAR BUFFER
  Location: kernel/proc.h (event queue structure)
  Structure:
    struct event {
      int pid;                    // 4 bytes
      char name[32];             // 32 bytes (e.g., "fork", "sleep", "write")
      uint64 timestamp;          // 8 bytes (kernel ticks)
    }                            // Total: 44 bytes
  
  Buffer:
    - Circular buffer with 256 slots
    - Front pointer (oldest unread event)
    - Rear pointer (next slot to write)
    - Spinlock for thread safety
    - When full: oldest event overwritten

STAGE 4: WATCHER READS EVENT
  Location: user/watcher.c
  Action: kqueue_wait(struct event *ev)
  
  Code in watcher:
    struct event ev;
    while(1) {
      if(kqueue_wait(&ev) < 0) break;
      // Process event (print, log, etc.)
    }

STAGE 5: WATCHER PROCESSES EVENT
  Action: Format and log/print event
  
  With `-i` flag (important only):
    - Check if event name starts with 'f' (fork) or 's' (sleep)
    - Skip 'w' (write) events
    - Add 100ms delay after each event
  
  With `-o filename` flag:
    - Write to file instead of console
    - Prevents output mixing
    - Can review later with: cat events.log

STAGE 6: WATCHER WAITS FOR NEXT EVENT
  Action: Loop back to kqueue_wait()
  Result: Blocked until next event arrives


================================================================================
4. WATCHER MONITORING FLOW
================================================================================

SCENARIO: Running "watcher -i -o events.log &"

TIME    ACTION
────    ──────────────────────────────────────────────────────────────────

0ms     $ watcher -i -o events.log &
        - watcher process starts
        - Opens "events.log" file (creates if not exists)
        - Enters main loop

1ms     Watcher calls kqueue_wait(&ev)
        - Kernel copies watcher to sleep
        - Watcher blocks waiting for events
        - Kernel switches to other processes

5ms     User types: eventtest
        - Shell starts
        - Events begin arriving

10ms    Shell fork() event
        - Kernel adds event to buffer: [fork, shell_pid, t10]
        - Watcher woken up by kernel (event arrived)
        - Watcher checks event type: 'f' = fork (important!)
        - Watcher logs to file: "[0] [2] fork"
        - Watcher adds 100ms delay (polling loop)

110ms   Delay complete
        - Watcher calls kqueue_wait() again
        - Blocks waiting for next event

115ms   eventtest fork() event
        - Kernel adds: [fork, eventtest_pid, t115]
        - Watcher wakes up
        - Watcher logs: "[105] [3] fork"
        - Watcher delays 100ms

...

Repeat until eventtest finishes

Final   Watcher still running
        - Continues monitoring for more events
        - Shell displays prompt
        - User can continue typing commands
        - Watcher captures events from new commands


================================================================================
5. COMPLETE TIMELINE EXAMPLES
================================================================================

EXAMPLE 1: eventtest Execution Timeline

Time(ms)  Event    PID    Description
────────  ─────    ───    ─────────────────────────────────────────────────
0         fork     2      Shell forks to execute eventtest
5         write    3      eventtest prints "Test: Creating fork events"
10        fork     3      eventtest creates child 1 (PID 7)
15        write    7      Child 1 prints "Child 7 running"
20        sleep    7      Child 1 waits during exit
30        fork     3      eventtest creates child 2 (PID 8)
35        write    8      Child 2 prints "Child 8 running"
40        sleep    8      Child 2 waits during exit
50        fork     3      eventtest creates child 3 (PID 9)
55        write    9      Child 3 prints "Child 9 running"
60        sleep    9      Child 3 waits during exit
70        write    3      eventtest prints "Test: Writing to console"
75        write    3      eventtest prints "Hello from test"
80        sleep    3      eventtest waits during exit
90        -        -      Shell resumes, displays $


EXAMPLE 2: echo hello Execution Timeline

Time(ms)  Event    PID    Description
────────  ─────    ───    ─────────────────────────────────────────────────
200       fork     2      Shell forks to execute echo
205       write    10     echo prints "hello"
210       sleep    10     echo waits during exit
215       -        -      Shell resumes, displays $


EXAMPLE 3: Multiple Commands in Sequence

$ watcher -i -o events.log &
$ eventtest
$ echo hello
$ forktest

events.log contains (only important events, -i flag):

[0] [2] fork          # Shell forks eventtest
[5] [3] fork          # eventtest creates child 1
[15] [3] fork         # eventtest creates child 2
[25] [3] fork         # eventtest creates child 3
[100] [2] fork        # Shell forks echo
[200] [2] fork        # Shell forks forktest
[210] [4] fork        # forktest creates children
[220] [5] fork        # forktest creates more children
[230] [6] fork        # forktest creates more children
...


================================================================================
6. KERNEL INTERNAL DETAILS
================================================================================

HOW fork() RECORDS EVENT:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Location: kernel/proc.c

Code flow:
  1. Process calls fork() syscall
  2. kernel/syscall.c routes to sys_fork()
  3. sys_fork() calls fork()
  
  fork() steps:
    a. Allocate new process structure
    b. Copy parent to child
    c. Set child's parent pointer
    d. Acquire spinlock on event queue
    e. Call kqueue_post(np->pid, "fork")  ← EVENT RECORDED
    f. Release spinlock
    g. Wakeup any waiting processes (watcher)
    h. Return child PID to parent, 0 to child


HOW write() RECORDS EVENT:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Location: kernel/sysfile.c

Code flow:
  1. Process calls write() syscall
  2. kernel/syscall.c routes to sys_write()
  
  sys_write() steps:
    a. Get file descriptor
    b. Check if fd is 1 (stdout) or 2 (stderr)
    c. If yes:
       - Acquire spinlock on event queue
       - Call kqueue_post(p->pid, "write")  ← EVENT RECORDED
       - Release spinlock
    d. Wakeup any waiting processes (watcher)
    e. Write data to console
    f. Return bytes written


HOW sleep() RECORDS EVENT:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Location: kernel/proc.c

Code flow:
  1. Process calls sleep(ticks) syscall
  2. kernel/syscall.c routes to sys_sleep()
  
  sys_sleep() steps:
    a. Get tick count to wait
    b. Acquire spinlock on event queue
    c. Call kqueue_post(p->pid, "sleep")  ← EVENT RECORDED
    d. Release spinlock
    e. Wakeup any waiting processes (watcher)
    f. Call sleep(ticks) to block process
    g. Wait for timeout
    h. Return to user space


HOW kqueue_wait() READS EVENTS:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Location: kernel/proc.c

Code flow:
  1. User process (watcher) calls kqueue_wait(struct event *ev)
  2. kernel/syscall.c routes to sys_kqueue_wait()
  
  sys_kqueue_wait() steps:
    a. Acquire spinlock on event queue
    b. If queue is empty:
       - Release spinlock
       - Call sleep() to block watcher
       - Wait for events to arrive
    c. If queue has events:
       - Get front event
       - Copy to user buffer (struct event *ev)
       - Increment front pointer
       - Release spinlock
       - Return 0 (success)
    d. If error:
       - Return -1


CIRCULAR BUFFER OPERATION:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Initial state (empty):
  front = 0, rear = 0, count = 0
  [_, _, _, _, _, ..., _]  (256 slots)

After first fork:
  front = 0, rear = 1, count = 1
  [fork_event, _, _, _, _, ..., _]

After three forks:
  front = 0, rear = 3, count = 3
  [fork, fork, fork, _, _, ..., _]

Watcher reads first event:
  front = 1, rear = 3, count = 2
  [_, fork, fork, _, _, ..., _]

When buffer fills up (256 events):
  front = 0, rear = 0 (wrapped around)
  When new event arrives: oldest event is overwritten
  front = 1, rear = 1
  [_, new_event, fork, fork, ..., fork]


SPINLOCK PROTECTION:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Why spinlock?
  - Multiple processes can call fork/sleep/write simultaneously
  - Watcher might be reading while kernel is writing
  - Without lock: race conditions and data corruption

How it works:
  Process 1 calls fork():
    1. Try to acquire spinlock
    2. Spinlock available → acquire it
    3. Add event to buffer
    4. Release spinlock
  
  Process 2 calls write() simultaneously:
    1. Try to acquire spinlock
    2. Spinlock held by Process 1 → spin (loop) waiting
    3. Spinlock released by Process 1 → acquire it
    4. Add event to buffer
    5. Release spinlock


================================================================================
7. DATA FLOW DIAGRAMS
================================================================================

COMPLETE SYSTEM DATA FLOW
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

User Types: $ eventtest
    ↓
┌─────────────────────┐
│   Shell Process     │
│   - Reads input     │
│   - Parses "eventtest"
│   - Calls fork()    │
└─────────────────────┘
    ↓
Kernel: fork() syscall
    ├─ Create child process
    ├─ Allocate PID
    └─ kqueue_post("fork") ──→ Event Buffer Slot [0]
    ↓
┌─────────────────────────────────┐
│   Watcher Process (sleeping)    │
│   kqueue_wait() blocked         │
│   Now wakes up due to event     │
└─────────────────────────────────┘
    ↓
Watcher reads Event [0]: fork
    ├─ Check: -i flag? Yes
    ├─ Check: fork important? Yes
    ├─ Format: "[0] [2] fork"
    ├─ Write to file "events.log"
    ├─ Delay 100ms (polling)
    └─ Call kqueue_wait() again → blocks
    ↓
eventtest Process (child created by fork)
    ├─ exec("eventtest")
    ├─ Loads binary
    └─ printf() → kqueue_post("write")
    ↓
New events arrive in buffer
    ├─ [1]: write event
    ├─ [2]: fork event
    ├─ [3]: write event
    └─ ...
    ↓
Watcher wakes up and processes each event
    ├─ Logs to file
    ├─ Delays 100ms
    ├─ Waits for next event
    └─ Repeats until done
    ↓
All events logged to events.log


PROCESS CREATION DURING fork()
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Parent Process (Shell)
    ↓
[User calls fork()]
    ↓
Kernel:
    1. Allocate new PCB (Process Control Block)
    2. Copy parent's page tables → child's memory space
    3. Copy parent's file descriptors
    4. Copy parent's registers
    5. Set child's PC (program counter) to fork's return point
    6. Assign new PID to child
    7. Set parent's PID in child's structure
    8. Add child to process list
    9. kqueue_post(child_pid, "fork") → Event recorded
   10. Return child's PID to parent
   11. Return 0 to child
    ↓
Parent continues                Child continues
fork() returns > 0              fork() returns 0
(has child_pid)                 (pid == 0, know we're child)
    ↓                               ↓
exec("eventtest")               [exec completes]
    ↓                               ↓
wait(0)                         eventtest code runs
(blocks here)                       ↓
    ↓                           printf/fork/exit calls
Blocked until child exits       ...
    ↓                               ↓
Child exits                     exit(0)
    ↓                               ↓
wait() returns                  Parent's wait() returns
    ↓                               ↓
Shell displays $                Shell displays $


FILE OUTPUT FLOW (-o flag)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

watcher -i -o events.log &

    ↓
Watcher opens file:
    open("events.log", O_CREATE | O_WRONLY) → fd = 3
    ↓
Main loop:
    ├─ kqueue_wait(&ev)
    ├─ ev = {pid: 2, name: "fork", timestamp: 123}
    ├─ Check: event.name[0] == 'f' ? YES (fork)
    ├─ Format event: "[0] [2] fork\n"
    ├─ write(fd=3, "[0] [2] fork\n", len)
    │   └─→ Kernel: write to file descriptor 3
    │       └─→ File I/O completed, event recorded
    ├─ Delay 100ms
    └─ Loop back to kqueue_wait()

Result: Clean output, no mixing with shell commands


================================================================================
8. PERFORMANCE METRICS
================================================================================

TIMING BREAKDOWN FOR eventtest:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Phase                          Time        Notes
───────────────────────────────────────────────────────────────────────
1. Shell fork()                ~5ms        Create process
2. eventtest loads (exec)      ~10ms       Load binary, pages
3. printf startup              ~2ms        Format string
4. First fork() call           ~5ms        Create child 1
5. Child 1 prints             ~3ms        write() syscall
6. Child 1 exit               ~5ms        Cleanup, wait
7. First wait() returns        ~2ms        Parent resumes
8. Second fork()              ~5ms        Create child 2
9. Child 2 prints             ~3ms        write() syscall
10. Child 2 exit              ~5ms        Cleanup
11. Second wait() returns      ~2ms        Parent resumes
12. Third fork()              ~5ms        Create child 3
13. Child 3 prints            ~3ms        write() syscall
14. Child 3 exit              ~5ms        Cleanup
15. Third wait() returns       ~2ms        Parent resumes
16. Final printf              ~3ms        write() syscall
17. Final write()             ~2ms        write() syscall
18. eventtest exit            ~5ms        Cleanup
───────────────────────────────────────────────────────────────────────
TOTAL                         ~93ms       Total execution time


EVENT BUFFER STATISTICS:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Maximum capacity:              256 events
Event size:                    44 bytes
Total buffer size:            11,264 bytes (~11 KB)
Max events before overflow:    256
Average event rate:           10 events/second (100ms per event with watcher delay)
Without watcher delay:        100+ events/second

For eventtest:
  Events generated:           ~12 events
  Buffer usage:               ~0.5% capacity


WATCHER PERFORMANCE WITH OPTIONS:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

watcher (all events)
  - Console output: Real-time
  - Output rate: ~100 lines/second
  - CPU usage: Low (mostly blocked on kqueue_wait)
  - Memory: ~37 KB

watcher -i (important only)
  - Console output: Filtered (fork, sleep only)
  - Output rate: ~20 lines/second (with 100ms delay)
  - CPU usage: Low (delayed by polling)
  - Memory: ~37 KB
  - Effect: No write event spam

watcher -o events.log (file output)
  - Console output: None (clean)
  - File writes: Atomic per event
  - File I/O time: ~5ms per write
  - File size: ~20 bytes per event

watcher -i -o events.log (best practice)
  - Console output: None (clean)
  - File writes: Only important events
  - File size: Small (~200 bytes for eventtest)
  - Total time: Low overhead


MEMORY USAGE:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

Component                      Size
────────────────────────────────────────────
Event queue buffer (256x44B)   11 KB
Spinlock (kernel)              64 bytes
PCB for watcher                ~1 KB
watcher binary code            ~37 KB
watcher stack                  ~4 KB
File descriptor table          ~1 KB
────────────────────────────────────────────
Total overhead                 ~55 KB


================================================================================

END OF SYSTEM WORKFLOW DOCUMENT

For detailed information on specific topics:
  - fork event:  See EVENTS_EXPLAINED.md section on "fork"
  - sleep event: See EVENTS_EXPLAINED.md section on "sleep"  
  - write event: See EVENTS_EXPLAINED.md section on "write"
  - Architecture: See DESIGN_DOCUMENT.md
  - Usage:       See USAGE_GUIDE.md

Last Updated: December 20, 2025
Repository: https://github.com/holisurt/xv6-subproject-kernel-event

================================================================================
